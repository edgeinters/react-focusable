{"version":3,"sources":["../../src/store/focusableBase.ts","../../src/utils/bounds.ts","../../src/utils/vector.ts","../../src/utils/frustum.ts","../../src/store/focusableDebugger.ts","../../src/store/focusablePath.ts","../../src/utils/direction.ts","../../src/store/focusable.ts","../../src/store/focusableContainer.ts","../../src/store/focus.ts","../../src/context/FocusableContext.ts","../../src/components/Focusable.tsx","../../src/hooks/useFocusable.ts","../../src/components/FocusableContainer.tsx","../../src/hooks/useFocusableContainer.ts","../../src/utils/draw.ts","../../src/components/FocusableDebugger.tsx","components/FocusableItem.tsx","components/FixedList.tsx","components/MenuItem.tsx","components/Menu.tsx","app.tsx","index.tsx"],"names":["FocusableDimension","FocusableDirection","TransformationDirection","FocusableBase","parent","key","bounds","_bounds","_enabled","this","makeObservable","observable","computed","enabled","setBounds","action","setEnabled","registerFocusable","keyPath","getBoundsTopLeft","x","y","getBoundsTopRight","width","getBoundsBottomLeft","height","getBoundsBottomRight","getBoundsPivot","getPositionsDistance","positionA","positionB","Math","sqrt","pow","transformPivotPosition","focusable","direction","boundsPosition","transformPosition","position","container","areVectorsClockwise","vector1","vector2","getFrustum","minPosition","maxPosition","DOWN","LEFT","RIGHT","UP","boundsPivot","maxAngle","atan2","maxVector","minAngle","minVector","isPivotInFrustum","pivot","frustum","pivotVector","_interactive","moves","_nextStep","currentMove","stepIndex","steps","length","splice","_previousStep","log","lastMove","setInteractive","stepFrom","stepOver","reaction","shouldStart","clearInterval","_interval","window","setInterval","message","optionalParams","console","interactive","stepBackward","stepForward","focusedDistancePoint","options","push","focus","_currentFocusableIndex","_focusables","focused","move","step","blur","stop","_dimension","UNKNOWN","_firstFocusable","distance","dimension","dimensionA","dimensionB","directionA","directionB","hasFocus","_distance","_timeout","abs","nextFocusableIndex","_getFocusableIndexFromHistory","focusableDebugger","nextFocus","getFocusable","unshift","max","distanceSign","setTimeout","stepTime","clearTimeout","VERTICAL","TO_PARENT","Focusable","isFocused","FocusablePath","isFocusable","undefined","FocusableContainer","getFocusableCallback","focusables","Object","values","filter","focusablePath","isBoundsInFrustum","sort","focusableA","focusableB","globalPivot","sortFocusablesByPivotDistance","nearestFocusable","transformFrustumTo","TO_CHILD","unregisterFocusable","unregisterFocusableWithKey","some","isFocusableContainer","down","left","HORIZONTAL","right","up","FocusableContext","React","createContext","observer","children","defaultFocus","disabled","focusableBounds","focusableKey","parentFocusableContainer","useContext","useState","setFocusable","useEffect","useFocusable","getFocusableOffset","focusableContainer","setFocusableContainer","useFocusableContainer","getFocusableOffsetCallback","Provider","value","clearContext","context","clearRect","innerWidth","innerHeight","drawBounds","style","lineWidth","strokeStyle","strokeRect","drawFocusableMove","point","beginPath","arc","PI","fillStyle","fill","stroke","drawPoint","i","globalBounds","forEach","option","FocusableDebugger","debugCanvas","setDebugCanvas","useLayoutEffect","onResize","canvas","addEventListener","removeEventListener","ref","canvasRef","getContext","zIndex","Styled","div","FocusableContent","props","FocusableItem","index","onFocus","StyledList","List","FixedList","listRef","useRef","useCallback","current","scrollToItem","disableHeight","itemCount","itemSize","layout","StyledButton","span","MenuItem","title","onRef","getBoundingClientRect","toLowerCase","StyledContainer","Menu","App","color","ReactDOM","render","document","getElementById","onkeyup"],"mappings":"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","file":"static/js/main.37fb4563.chunk.js","sourcesContent":["import { action, computed, makeObservable, observable } from \"mobx\"\nimport { Focusable } from \"./focusable\"\nimport { FocusableContainer } from \"./focusableContainer\"\n\nexport type FocusableCallback = (frustum: FocusableFrustum, direction: FocusableDirection) => Focusable | null\nexport type FocusableOffsetCallback = () => FocusablePosition\n\nexport interface FocusableBounds extends FocusablePosition {\n    height: number\n    width: number,\n}\n\nexport enum FocusableDimension {\n    HORIZONTAL = 'HORIZONTAL',\n    VERTICAL = 'VERTICAL',\n    UNKNOWN = 'UNKNOWN'\n}\n\nexport enum FocusableDirection {\n    DOWN = 'DOWN',\n    LEFT = 'LEFT',\n    RIGHT = 'RIGHT',\n    UP = 'UP',\n    UNKNOWN = 'UNKNOWN'\n}\n\nexport interface FocusableFrustum extends FocusablePosition {\n    minAngle: number | null\n    minVector: FocusablePosition | null\n    maxAngle: number | null\n    maxVector: FocusablePosition | null\n}\n\nexport interface FocusablePosition {\n    x: number\n    y: number\n}\n\nexport interface FocusableInterface {\n    readonly bounds: FocusableBounds\n    readonly isEnabled: boolean\n    readonly key: string\n}\n\nexport class FocusableBase {\n\n    readonly key: string\n    readonly parent: FocusableContainer | null\n\n    private _bounds: FocusableBounds | null = null\n    private _enabled: boolean = true\n\n    get bounds() {\n        return this._bounds\n    }\n\n    get enabled() {\n        return this._enabled\n    }\n\n    get keyPath(): string {\n        if (!this.parent) return this.key\n\n        return `${this.parent.keyPath}.${this.key}`\n    }\n\n    constructor(parent: FocusableContainer | null, key: string, bounds: FocusableBounds | null = null) {\n        this.key = key\n        this.parent = parent\n\n        this._bounds = bounds\n\n        makeObservable<FocusableBase,\n            '_bounds' |\n            '_enabled'\n        >(this, {\n            _bounds: observable,\n            _enabled: observable,\n            bounds: computed,\n            enabled: computed,\n            setBounds: action,\n            setEnabled: action,\n        })\n\n        if (this.parent) {\n            this.parent.registerFocusable(this)\n        }\n    }\n\n    setBounds(bounds: FocusableBounds | null) {\n        this._bounds = bounds\n    }\n\n    setEnabled(enabled: boolean) {\n        this._enabled = enabled\n    }\n\n}","import { FocusableBase, FocusableBounds, FocusablePosition } from \"../store/focusableBase\";\n\nexport enum TransformationDirection {\n    'TO_PARENT' = 1,\n    'TO_CHILD' = -1,\n}\n\nexport const getBoundsTopLeft = (bounds: FocusableBounds): FocusablePosition => {\n    return {\n        x: bounds.x,\n        y: bounds.y,\n    }\n}\n\nexport const getBoundsTopRight = (bounds: FocusableBounds): FocusablePosition => {\n    return {\n        x: bounds.x + bounds.width,\n        y: bounds.y,\n    }\n}\n\nexport const getBoundsBottomLeft = (bounds: FocusableBounds): FocusablePosition => {\n    return {\n        x: bounds.x,\n        y: bounds.y + bounds.height,\n    }\n}\n\nexport const getBoundsBottomRight = (bounds: FocusableBounds): FocusablePosition => {\n    return {\n        x: bounds.x + bounds.width,\n        y: bounds.y + bounds.height,\n    }\n}\n\nexport const getBoundsPivot = (bounds: FocusableBounds): FocusablePosition => {\n    return {\n        x: bounds.x + bounds.width / 2,\n        y: bounds.y + bounds.height / 2\n    }\n}\n\nexport const getBoundsPivotDistance = (bounds: FocusableBounds, pivot: FocusablePosition): number => {\n    const boundsPivot = getBoundsPivot(bounds)\n\n    return getPositionsDistance(boundsPivot, pivot)\n}\n\nexport const getPositionsDistance = (positionA: FocusablePosition, positionB: FocusablePosition): number => {\n    return Math.sqrt(Math.pow(positionA.x - positionB.x, 2) + Math.pow(positionA.y - positionB.y, 2))\n}\n\nexport const sortBoundsByPivotDistance = (boundsA: FocusableBounds, boundsB: FocusableBounds, pivot: FocusablePosition): number => {\n    const distanceA = getBoundsPivotDistance(boundsA, pivot)\n    const distanceB = getBoundsPivotDistance(boundsB, pivot)\n\n    if (distanceA <= distanceB) return -1\n    return 1\n}\n\nexport const sortFocusablesByPivotDistance = (focusableA: FocusableBase, focusableB: FocusableBase, globalPivot: FocusablePosition): number => {\n    const positionA = transformPivotPosition(focusableA, TransformationDirection.TO_PARENT)\n    const positionB = transformPivotPosition(focusableB, TransformationDirection.TO_PARENT)\n\n    if (getPositionsDistance(positionA, globalPivot) <= getPositionsDistance(positionB, globalPivot)) return -1\n    return 1\n}\n\nexport const transformPivotPosition = (focusable: FocusableBase, direction: TransformationDirection): FocusablePosition => {\n    if (!focusable.bounds) return { x: 0, y: 0 }\n\n    const boundsPosition = transformPosition(focusable, direction)\n\n    return getBoundsPivot({\n        ...focusable.bounds,\n        ...boundsPosition\n    })\n}\n\nexport const transformPosition = (focusable: FocusableBase, direction: TransformationDirection): FocusablePosition => {\n    let position = focusable.bounds ? { ...focusable.bounds } : { x: 0, y: 0 }\n    let container = focusable.parent\n\n    while (container) {\n        if (container.bounds) {\n            position.x += container.bounds.x * direction\n            position.y += container.bounds.y * direction\n        }\n\n        container = container.parent\n    }\n\n    return position\n}","import { FocusablePosition } from \"../store/focusableBase\"\n\nexport const areVectorsClockwise = (vector1: FocusablePosition, vector2: FocusablePosition) => {\n    return -vector1.x * vector2.y + vector1.y * vector2.x > 0\n}","import { FocusableBounds, FocusableDirection, FocusableFrustum, FocusablePosition } from \"../store/focusableBase\";\nimport { getBoundsBottomLeft, getBoundsBottomRight, getBoundsPivot, getBoundsTopLeft, getBoundsTopRight, TransformationDirection } from \"./bounds\";\nimport { areVectorsClockwise } from \"./vector\";\n\nexport const getFrustum = (bounds: FocusableBounds, direction: FocusableDirection): FocusableFrustum => {\n    let minPosition: FocusablePosition | null = null\n    let maxPosition: FocusablePosition | null = null\n\n    switch (direction) {\n        case FocusableDirection.DOWN:\n            minPosition = getBoundsBottomRight(bounds)\n            maxPosition = getBoundsBottomLeft(bounds)\n            break\n        case FocusableDirection.LEFT:\n            minPosition = getBoundsBottomLeft(bounds)\n            maxPosition = getBoundsTopLeft(bounds)\n            break\n        case FocusableDirection.RIGHT:\n            minPosition = getBoundsTopRight(bounds)\n            maxPosition = getBoundsBottomRight(bounds)\n            break\n        case FocusableDirection.UP:\n            minPosition = getBoundsTopLeft(bounds)\n            maxPosition = getBoundsTopRight(bounds)\n            break\n    }\n\n    const boundsPivot = getBoundsPivot(bounds)\n    const maxAngle = maxPosition && Math.atan2(maxPosition.y - boundsPivot.y, maxPosition.x - boundsPivot.x)\n    const maxVector = maxPosition && {\n        x: maxPosition.x - boundsPivot.x,\n        y: maxPosition.y - boundsPivot.y\n    }\n    const minAngle = minPosition && Math.atan2(minPosition.y - boundsPivot.y, minPosition.x - boundsPivot.x)\n    const minVector = minPosition && {\n        x: minPosition.x - boundsPivot.x,\n        y: minPosition.y - boundsPivot.y\n    }\n\n    return {\n        maxAngle,\n        maxVector,\n        minAngle,\n        minVector,\n        x: boundsPivot.x,\n        y: boundsPivot.y,\n    }\n\n}\n\nexport const isBoundsInFrustum = (bounds: FocusableBounds, frustum: FocusableFrustum): boolean => {\n    const boundsPivot = getBoundsPivot(bounds)\n\n    return isPivotInFrustum(boundsPivot, frustum)\n}\n\nexport const isPivotInFrustum = (pivot: FocusablePosition, frustum: FocusableFrustum): boolean => {\n    const pivotVector: FocusablePosition = {\n        x: pivot.x - frustum.x,\n        y: pivot.y - frustum.y,\n    }\n\n    if (!frustum.maxVector || !frustum.minVector) return true\n\n    return !areVectorsClockwise(frustum.minVector, pivotVector) &&\n        areVectorsClockwise(frustum.maxVector, pivotVector)\n}\n\nexport const transformFrustumTo = (frustum: FocusableFrustum, bounds: FocusableBounds | null, direction: TransformationDirection): FocusableFrustum => {\n    if (!bounds) return frustum\n\n    return {\n        ...frustum,\n        x: frustum.x + bounds.x * direction,\n        y: frustum.y + bounds.y * direction\n    }\n}","import { action, computed, makeObservable, observable, reaction } from \"mobx\";\nimport { Focusable } from \"./focusable\";\nimport { FocusableBase, FocusableFrustum, FocusablePosition } from \"./focusableBase\";\n\nexport interface FocusableMove {\n    focusedDistancePoint: FocusablePosition\n    stepIndex: number\n    steps: {\n        focusable: FocusableBase\n        frustum: FocusableFrustum\n        options: FocusableBase[]\n    }[]\n}\n\nclass FocusableDebugger {\n\n    private _enabled: boolean = false\n    private _interactive: boolean = false\n    private _interval: number\n\n    moves: FocusableMove[] = []\n\n    get currentMove() {\n        return (this.moves.length && this.moves[0]) || null\n    }\n\n    get lastMove() {\n        return (this.moves.length && this.moves[this.moves.length - 1]) || null\n    }\n\n    constructor() {\n        makeObservable<FocusableDebugger, '_enabled' | '_interactive' | '_nextStep'>(this, {\n            _enabled: observable,\n            _interactive: observable,\n            _nextStep: action,\n            currentMove: computed,\n            lastMove: computed,\n            moves: observable,\n            setEnabled: action,\n            setInteractive: action,\n            stepFrom: action,\n            stepOver: action,\n        })\n\n        reaction(() => this.moves.length > 0 && this._enabled && !this._interactive,\n            (shouldStart) => {\n                clearInterval(this._interval)\n\n                if (shouldStart) {\n                    this._interval = window.setInterval(this._nextStep, 300)\n                }\n            })\n    }\n\n    log(message: any, ...optionalParams: any[]) {\n        if (!this._enabled) return\n\n        console.log('[FocusableDebugger]', message, ...optionalParams)\n    }\n\n    setEnabled(enabled: boolean) {\n        this._enabled = enabled\n    }\n\n    setInteractive(interactive: boolean) {\n        this._interactive = interactive\n    }\n\n    stepBackward() {\n        if (!this._interactive) {\n            this.log('Interaction is not enabled. Set interactive prop on <FocusableDebugger/>')\n            return\n        }\n\n        this._previousStep()\n    }\n\n    stepForward() {\n        if (!this._interactive) {\n            this.log('Interaction is not enabled. Set interactive prop on <FocusableDebugger/>')\n            return\n        }\n\n        this._nextStep()\n    }\n\n    stepFrom(focusable: Focusable, frustum: FocusableFrustum, focusedDistancePoint: FocusablePosition) {\n        if (!this._enabled) return\n\n        this.moves = [{\n            focusedDistancePoint,\n            stepIndex: 0,\n            steps: [{\n                focusable,\n                frustum,\n                options: []\n            }],\n        }]\n    }\n\n    stepOver(focusable: FocusableBase, frustum: FocusableFrustum, options: FocusableBase[]) {\n        if (!this._enabled) return\n\n        this.lastMove?.steps.push({\n            focusable,\n            frustum,\n            options\n        })\n    }\n\n    private _nextStep = () => {\n        if (!this.currentMove) return\n\n        if (this.currentMove.stepIndex < this.currentMove.steps.length - 1) {\n            this.currentMove.stepIndex++\n        } else {\n            this.moves.splice(0, 1)\n        }\n    }\n\n    private _previousStep = () => {\n        if (!this.currentMove) return\n\n        if (this.currentMove.stepIndex > 0) {\n            this.currentMove.stepIndex--\n        } else {\n            this.log('It is not possible to go to the previous move. Interaction works only within current move')\n        }\n    }\n}\n\nexport default new FocusableDebugger()","import { action, computed, makeObservable, observable } from \"mobx\";\n\nimport { TransformationDirection, transformPivotPosition } from \"../utils/bounds\";\nimport { isOppositeDimensions, isOppositeDirection } from \"../utils/direction\";\nimport { getFrustum } from \"../utils/frustum\";\nimport { Focusable } from \"./focusable\";\nimport { FocusableDimension, FocusableDirection, FocusablePosition } from \"./focusableBase\";\nimport focusableDebugger from \"./focusableDebugger\";\n\nconst DEFAULT_STEP_TIME = 100\n\nclass FocusablePath {\n\n    private _currentFocusableIndex: number\n    private _dimension: FocusableDimension\n    private _distance: number\n    private _firstFocusable: Focusable | null\n    private _focusables: Focusable[]\n    private _timeout: number\n\n    get dimension() {\n        return this._dimension\n    }\n\n    get direction() {\n        if (this._dimension === FocusableDimension.VERTICAL) {\n            return this._distance < 0 ? FocusableDirection.UP : FocusableDirection.DOWN\n        } else {\n            return this._distance < 0 ? FocusableDirection.LEFT : FocusableDirection.RIGHT\n        }\n    }\n\n    get distanceSign() {\n        if (this._distance < 0) return -1\n        return 1\n    }\n\n    get focused(): Focusable | null {\n        return this._focusables[this._currentFocusableIndex] || null\n    }\n\n    get focusedDistancePoint(): FocusablePosition {\n        return (this._firstFocusable && transformPivotPosition(this._firstFocusable, TransformationDirection.TO_PARENT)) || { x: 0, y: 0 }\n    }\n\n    get hasFocus() {\n        return this.focused !== null\n    }\n\n    get stepTime() {\n        return DEFAULT_STEP_TIME\n    }\n\n    constructor() {\n        this.focus(null)\n\n        makeObservable<FocusablePath,\n            '_currentFocusableIndex' |\n            '_focusables'\n        >(this, {\n            _currentFocusableIndex: observable,\n            _focusables: observable,\n            focus: action,\n            focused: computed,\n            move: action,\n            step: action\n        })\n    }\n\n    blur() {\n        this.stop()\n\n        console.log('blur!');\n    }\n\n    focus(focusable: Focusable | null) {\n        this.stop()\n\n        this._dimension = FocusableDimension.UNKNOWN\n        this._firstFocusable = focusable\n        this._focusables = focusable ? [focusable] : []\n        this._currentFocusableIndex = 0\n    }\n\n    move(distance: number, dimension: FocusableDimension) {\n        if (!this.hasFocus) {\n            return\n        }\n\n        if (isOppositeDimensions(this._dimension, dimension)) {\n            this.focus(this.focused)\n        }\n\n        if (isOppositeDirection(distance, this._distance)) {\n            this.stop()\n        }\n\n        this._dimension = dimension\n        this._distance += distance\n\n        if (!this._timeout) {\n            this.step()\n        }\n    }\n\n    step() {\n        if (Math.abs(this._distance) < 0.5 || !this.focused || !this.focused.bounds) {\n            return this.stop()\n        }\n\n\n        let nextFocusableIndex = this._getFocusableIndexFromHistory()\n        if (nextFocusableIndex < 0) { // history can't be used\n            const frustum = getFrustum(this.focused.bounds, this.direction)\n            focusableDebugger.stepFrom(this.focused, frustum, this.focusedDistancePoint)\n\n            const nextFocus = this.focused?.parent.getFocusable(frustum, this.direction)\n\n            if (!nextFocus) {\n                return this.stop()\n            }\n\n            if (this._distance < 0) {\n                this._focusables.unshift(nextFocus)\n                nextFocusableIndex = 0\n            } else {\n                this._focusables.push(nextFocus)\n                nextFocusableIndex = this._focusables.length - 1\n            }\n\n            focusableDebugger.stepOver(this._focusables[nextFocusableIndex], frustum, [])\n        } else {\n            focusableDebugger.log('using focusable history')\n        }\n\n        this._currentFocusableIndex = nextFocusableIndex\n\n        this._distance = Math.max(Math.abs(this._distance) - 1, 0) * this.distanceSign\n        this._timeout = window.setTimeout(() => this.step(), this.stepTime)\n    }\n\n    stop() {\n        clearTimeout(this._timeout)\n\n        this._distance = 0\n        this._timeout = 0\n    }\n\n    private _getFocusableIndexFromHistory(): number {\n        if (this._distance > 0 && this._currentFocusableIndex < this._focusables.length - 1) {\n            return this._currentFocusableIndex + 1\n        }\n\n        if (this._distance < 0 && this._currentFocusableIndex > 0) {\n            return this._currentFocusableIndex - 1\n        }\n\n        return -1\n    }\n\n}\n\nexport default new FocusablePath()","import { FocusableDimension } from \"../store/focusableBase\"\n\nexport const isOppositeDimensions = (dimensionA: FocusableDimension, dimensionB: FocusableDimension): boolean => {\n    return dimensionA !== dimensionB && dimensionA !== FocusableDimension.UNKNOWN && dimensionB !== FocusableDimension.UNKNOWN\n}\n\nexport const isOppositeDirection = (directionA: number, directionB: number): boolean => {\n    return directionA * directionB < 0\n}","import { computed, makeObservable } from 'mobx'\n\nimport { FocusableBase, FocusableBounds } from './focusableBase'\nimport { FocusableContainer } from './focusableContainer'\nimport FocusablePath from './focusablePath'\n\nexport class Focusable extends FocusableBase {\n\n    readonly parent: FocusableContainer\n\n    get isFocused() {\n        return FocusablePath.focused === this\n    }\n\n    constructor(parent: FocusableContainer, key: string, bounds: FocusableBounds | null = null) {\n        super(parent, key, bounds)\n\n        makeObservable(this, {\n            isFocused: computed,\n        })\n    }\n\n    focus() {\n        FocusablePath.focus(this)\n    }\n\n}\n\nexport const isFocusable = (focusable: FocusableBase): focusable is Focusable => {\n    return (focusable as Focusable).focus !== undefined\n}","import { sortFocusablesByPivotDistance, TransformationDirection } from \"../utils/bounds\"\nimport { getFrustum, isBoundsInFrustum, transformFrustumTo } from \"../utils/frustum\"\nimport { Focusable, isFocusable } from \"./focusable\"\nimport { FocusableBase, FocusableBounds, FocusableCallback, FocusableDirection, FocusableFrustum, FocusableOffsetCallback } from \"./focusableBase\"\nimport focusableDebugger from \"./focusableDebugger\"\nimport focusablePath from \"./focusablePath\"\n\nexport class FocusableContainer extends FocusableBase {\n\n    private _focusables: { [key: string]: FocusableBase } = {}\n\n    getFocusableCallback?: FocusableCallback\n    getFocusableOffsetCallback?: FocusableOffsetCallback\n\n    get focusables() {\n        return this._focusables\n    }\n\n    get hasFocus(): boolean {\n        return Object.values(this._focusables).some(focusable => {\n            if (isFocusableContainer(focusable)) return focusable.hasFocus\n            if (isFocusable(focusable)) return focusable.isFocused\n            return false\n        })\n    }\n\n    constructor(parent: FocusableContainer | null, key: string, bounds: FocusableBounds | null = null) {\n        super(parent, key, bounds)\n    }\n\n    getFocusable(frustum: FocusableFrustum, direction: FocusableDirection): Focusable | null {\n        focusableDebugger.log('getFocusableForContainer', this.keyPath, {\n            frustum,\n        })\n\n        const focusable = this.getFocusableCallback && this.getFocusableCallback(frustum, direction)\n        if (focusable) {\n            focusableDebugger.stepOver(this, frustum, [])\n            return focusable\n        }\n\n        const focusables = Object.values(this.focusables)\n            .filter((focusable) => {\n                if (focusable === focusablePath.focused || (focusable as FocusableContainer).hasFocus) return false\n\n                return focusable.bounds && isBoundsInFrustum(focusable.bounds, frustum)\n            })\n            .sort((focusableA, focusableB) => sortFocusablesByPivotDistance(focusableA, focusableB, focusablePath.focusedDistancePoint))\n\n        focusableDebugger.stepOver(this, frustum, focusables)\n\n        const nearestFocusable = focusables[0]\n\n        // no focusable on the same level, we have to try upper\n        // if (!nearestFocusable) return this.parent?.getFocusable(transformFrustumTo(frustum, this.bounds, TransformationDirection.TO_PARENT), direction) || null\n        if (!nearestFocusable) return this.parent?.getFocusable(getFrustum(this.bounds!, direction), direction) || null\n\n        // we found focusable to which to five focus\n        if (isFocusable(nearestFocusable)) return nearestFocusable\n\n        // we found focusableContainer on the same level, lets get focusable from him\n        return (nearestFocusable as FocusableContainer).getFocusable(transformFrustumTo(frustum, nearestFocusable.bounds, TransformationDirection.TO_CHILD), direction)\n    }\n\n    registerFocusable(focusable: FocusableBase) {\n        console.log('registerFocusable: ', focusable.key);\n        this._focusables[focusable.key] = focusable\n\n        // If no another focusable is focused, focus it\n        if (!focusablePath.hasFocus && isFocusable(focusable) && focusable.enabled) {\n            focusablePath.focus(focusable)\n        }\n    }\n\n    unregisterFocusable(focusable: FocusableBase) {\n        delete this._focusables[focusable.key]\n\n        // Notify path, that focused item is destroying and loosing focus\n        if (isFocusable(focusable) && focusable.isFocused) {\n            focusablePath.blur()\n        }\n    }\n\n    unregisterFocusableWithKey(key: string) {\n        if (this._focusables[key]) {\n            this.unregisterFocusable(this._focusables[key])\n        }\n    }\n\n}\n\nexport const isFocusableContainer = (focusable: FocusableBase): focusable is FocusableContainer => {\n    return (focusable as FocusableContainer).focusables !== undefined\n}","import { FocusableDimension } from \"./focusableBase\"\nimport { FocusableContainer } from \"./focusableContainer\"\nimport FocusablePath from \"./focusablePath\"\n\nclass Focus extends FocusableContainer {\n\n    constructor() {\n        super(null, 'root')\n\n        this.setBounds({\n            height: 0,\n            width: 0,\n            x: 0,\n            y: 0\n        })\n    }\n\n    down(distance: number = 1) {\n        FocusablePath.move(distance, FocusableDimension.VERTICAL)\n    }\n\n    left(distance: number = 1) {\n        FocusablePath.move(distance * -1, FocusableDimension.HORIZONTAL)\n    }\n\n    right(distance: number = 1) {\n        FocusablePath.move(distance, FocusableDimension.HORIZONTAL)\n    }\n\n    up(distance: number = 1) {\n        FocusablePath.move(distance * -1, FocusableDimension.VERTICAL)\n    }\n\n}\n\nexport default new Focus()","import React from \"react\";\n\nimport { focus } from \"../store\";\nimport { FocusableContainer } from \"../store/focusableContainer\";\n\nexport const FocusableContext = React.createContext<FocusableContainer>(focus)","import { observer } from 'mobx-react-lite'\nimport React, { useEffect } from \"react\"\n\nimport { useFocusable } from \"../hooks/useFocusable\"\nimport { Focusable as FocusableStore } from '../store/focusable'\nimport { FocusableBounds } from '../store/focusableBase'\n\nexport interface FocusableProps {\n    children?: React.ReactNode | ((focusable: FocusableStore) => React.ReactNode)\n    defaultFocus?: boolean\n    disabled?: boolean\n    focusableBounds: FocusableBounds | null\n    focusableKey: string\n}\n\nexport const Focusable = observer(({ children, defaultFocus, disabled, focusableBounds, focusableKey }: FocusableProps) => {\n    const focusable = useFocusable(focusableKey, focusableBounds)\n\n    useEffect(() => {\n        if (focusable && defaultFocus) {\n            focusable.focus()\n        }\n    }, [focusable, defaultFocus])\n\n    useEffect(() => {\n        focusable?.setEnabled(!disabled)\n    }, [focusable, disabled])\n\n    useEffect(() => {\n        focusable?.setBounds(focusableBounds)\n    }, [focusableBounds])\n\n    if (!focusable) return\n\n    return typeof children === 'function' ?\n        children(focusable) :\n        children\n})","import { useContext, useEffect, useState } from \"react\"\n\nimport { FocusableContext } from \"../context\"\nimport { Focusable } from \"../store/focusable\";\nimport { FocusableBounds } from \"../store/focusableBase\";\n\nexport const useFocusable = (focusableKey: string, focusableBounds: FocusableBounds | null = null) => {\n    const parentFocusableContainer = useContext(FocusableContext)\n    const [focusable, setFocusable] = useState<Focusable>()\n\n    useEffect(() => {\n        const focusable = new Focusable(parentFocusableContainer, focusableKey, focusableBounds)\n        setFocusable(focusable)\n\n        return () => parentFocusableContainer.unregisterFocusable(focusable)\n    }, [])\n\n    return focusable\n}","import React, { useEffect } from \"react\"\n\nimport { FocusableContext } from \"../context\"\nimport { useFocusableContainer } from \"../hooks/useFocusableContainer\"\nimport { FocusableBaseTypes } from \"../store\"\nimport { FocusableBounds } from \"../store/focusableBase\"\n\nexport interface FocusableContainerProps {\n    children?: React.ReactNode\n    disabled?: boolean\n    focusableBounds: FocusableBounds | null\n    focusableKey: string\n    getFocusable?: FocusableBaseTypes.FocusableCallback\n    getFocusableOffset?: FocusableBaseTypes.FocusableOffsetCallback\n}\n\nexport const FocusableContainer = ({ children, disabled, focusableBounds, focusableKey, getFocusable, getFocusableOffset }: FocusableContainerProps) => {\n    const focusableContainer = useFocusableContainer(focusableKey, focusableBounds)\n\n    useEffect(() => {\n        if (!focusableContainer) return\n\n        focusableContainer.getFocusableCallback = getFocusable\n        focusableContainer.getFocusableOffsetCallback = getFocusableOffset\n    }, [FocusableContainer])\n\n    useEffect(() => {\n        focusableContainer?.setEnabled(!disabled)\n    }, [disabled])\n\n    useEffect(() => {\n        focusableContainer?.setBounds(focusableBounds)\n    }, [focusableBounds])\n\n    if (!focusableContainer) return null\n\n    return (\n        <FocusableContext.Provider value={focusableContainer}>\n            {children}\n        </FocusableContext.Provider>\n    )\n}","import { useContext, useEffect, useState } from \"react\"\n\nimport { FocusableContext } from \"../context\"\nimport { FocusableBounds } from \"../store/focusableBase\";\nimport { FocusableContainer } from \"../store/focusableContainer\";\n\nexport const useFocusableContainer = (focusableKey: string, focusableBounds: FocusableBounds | null = null) => {\n    const parentFocusableContainer = useContext(FocusableContext)\n    const [focusableContainer, setFocusableContainer] = useState<FocusableContainer>()\n\n    useEffect(() => {\n        const focusableContainer = new FocusableContainer(parentFocusableContainer, focusableKey, focusableBounds)\n        setFocusableContainer(focusableContainer)\n\n        return () => focusableContainer.unregisterFocusable(focusableContainer)\n    }, [])\n\n    return focusableContainer\n}","import { FocusableBounds, FocusableFrustum, FocusablePosition } from \"../store/focusableBase\"\nimport { FocusableMove } from \"../store/focusableDebugger\"\nimport { TransformationDirection, transformPosition } from \"./bounds\"\n\nexport const clearContext = (context: CanvasRenderingContext2D) => {\n    context.clearRect(0, 0, window.innerWidth, window.innerHeight)\n}\n\nexport const drawBounds = (bounds: FocusableBounds, context: CanvasRenderingContext2D, style: string) => {\n    context.lineWidth = 2\n    context.strokeStyle = style\n    context.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height)\n}\n\nexport const drawFrustum = (frustum: FocusableFrustum, context: CanvasRenderingContext2D) => {\n    drawPoint(frustum, context)\n}\n\nexport const drawPoint = (point: FocusablePosition, context: CanvasRenderingContext2D) => {\n    context.beginPath();\n    context.arc(point.x, point.y, 5, 0, 2 * Math.PI, false);\n    context.fillStyle = 'red';\n    context.fill();\n    context.stroke();\n}\n\nexport const drawFocusableMove = (move: FocusableMove, context: CanvasRenderingContext2D) => {\n    clearContext(context)\n\n    drawPoint(move.focusedDistancePoint, context)\n\n    for (let i = 0; i <= move.stepIndex; ++i) {\n        const step = move.steps[i]\n\n        const globalBounds = transformPosition(step.focusable, TransformationDirection.TO_PARENT)\n        // const globalFrustum = {\n        //     ...step.frustum,\n        //     x: step.frustum.x + (globalBounds.x - step.focusable.bounds!.x),\n        //     y: step.frustum.y + (globalBounds.y - step.focusable.bounds!.y)\n        // }\n\n        // drawFrustum(globalFrustum, context)\n        step.options?.forEach(option => {\n            drawBounds(transformPosition(option, TransformationDirection.TO_PARENT) as FocusableBounds, context, 'green')\n        })\n        drawBounds(globalBounds as FocusableBounds, context, 'red')\n    }\n}","import { observer } from 'mobx-react-lite'\nimport React, { useEffect, useLayoutEffect, useState } from 'react'\n\nimport focusableDebugger from '../store/focusableDebugger'\nimport { clearContext, drawFocusableMove } from '../utils/draw'\n\ninterface FocusableDebuggerProps {\n    enabled?: boolean\n    interactive?: boolean\n}\n\nexport const FocusableDebugger = observer(({ enabled = true, interactive = false }: FocusableDebuggerProps) => {\n    const [debugCanvas, setDebugCanvas] = useState<{ canvas: HTMLCanvasElement, context: CanvasRenderingContext2D }>()\n\n    useEffect(() => {\n        focusableDebugger.setEnabled(enabled)\n\n        return () => focusableDebugger.setEnabled(false)\n    }, [enabled])\n\n    useEffect(() => {\n        focusableDebugger.setInteractive(interactive)\n\n        return () => focusableDebugger.setInteractive(false)\n    }, [interactive])\n\n    useEffect(() => {\n        if (!debugCanvas) return\n\n        if (focusableDebugger.currentMove) {\n            drawFocusableMove(focusableDebugger.currentMove, debugCanvas.context)\n        } else {\n            clearContext(debugCanvas.context)\n        }\n    }, [focusableDebugger.currentMove, focusableDebugger.currentMove?.stepIndex])\n\n    useLayoutEffect(() => {\n        const onResize = () => {\n            if (!debugCanvas) return\n\n            debugCanvas.canvas.width = window.innerWidth\n            debugCanvas.canvas.height = window.innerHeight\n\n            if (focusableDebugger.currentMove) {\n                drawFocusableMove(focusableDebugger.currentMove, debugCanvas.context)\n            }\n        }\n\n        window.addEventListener('resize', onResize)\n        onResize()\n\n        return () => window.removeEventListener('resize', onResize)\n    }, [debugCanvas])\n\n    return (\n        <canvas\n            ref={(canvasRef) => {\n                if (canvasRef && !debugCanvas)\n                    setDebugCanvas({ canvas: canvasRef, context: canvasRef.getContext('2d')! })\n            }}\n            style={{ position: 'absolute', zIndex: 9999 }}\n        />\n    )\n\n})","import React from 'react'\nimport { Focusable, FocusableBaseTypes } from 'react-focusable'\nimport Styled from 'styled-components'\n\ninterface FocusableItemProps {\n    defaultFocus?: boolean\n    focusableBounds: FocusableBaseTypes.FocusableBounds | null\n    index: number\n    onFocus: (index: number) => void\n    style?: React.CSSProperties\n}\n\nconst FocusableContainer = Styled.div`\n    box-sizing: border-box;\n    padding-right: 20px;\n`\n\nconst FocusableContent = Styled.div<{ isFocused?: boolean }>`\n    background-color: rgba(0, 147, 255, ${props => props.isFocused ? 1 : 0.4});\n    border-radius: 10px;\n    height: 100%;\n    width: 100%;\n`\n\nexport const FocusableItem = ({ defaultFocus, focusableBounds, index, onFocus, ...props }: FocusableItemProps) => {\n    return (\n        <Focusable\n            defaultFocus={defaultFocus}\n            focusableKey={`item-${index}`}\n            focusableBounds={focusableBounds}\n        >\n            {(focusable) => {\n                if (focusable.isFocused) {\n                    onFocus(index)\n                }\n\n                return (\n                    <FocusableContainer {...props} >\n                        <FocusableContent isFocused={focusable.isFocused} />\n                    </FocusableContainer>\n                )\n            }}\n        </Focusable >\n    )\n\n}","import React, { useCallback, useRef } from 'react'\nimport { FocusableContainer } from 'react-focusable'\nimport AutoSizer from 'react-virtualized-auto-sizer'\nimport { FixedSizeList as List } from 'react-window'\nimport Styled from 'styled-components'\n\nimport { FocusableItem } from './FocusableItem'\n\ninterface FixedListProps {\n    defaultFocus?: boolean\n    focusableKey: string\n    style?: React.CSSProperties\n}\n\nconst StyledList = Styled(List)`\n    margin: 0px;\n`\n\nexport const FixedList = ({ defaultFocus, focusableKey, ...props }: FixedListProps) => {\n    const listRef = useRef<List>(null)\n\n    // const getFocusableCallback = useCallback((frustum: FocusableBaseTypes.FocusableFrustum, direction: FocusableBaseTypes.FocusableDirection) => {\n    //     return null\n    // }, [])\n\n    const onFocus = useCallback((index: number) => {\n        listRef.current?.scrollToItem(index, 'auto')\n    }, [listRef])\n\n    return (\n        <AutoSizer disableHeight>\n            {({ width }) => {\n                return (\n                    <FocusableContainer\n                        focusableBounds={{ x: 0, y: 500, width, height: 200 }}\n                        focusableKey={focusableKey}\n                    >\n                        <StyledList\n                            height={200}\n                            itemCount={100}\n                            itemSize={200}\n                            ref={listRef}\n                            width={width}\n                            layout=\"horizontal\"\n                            // onScroll={(props) => console.log(props)}\n                            {...props}\n                        >\n                            {(props) => {\n                                return <FocusableItem\n                                    focusableBounds={{ x: props.index * 200, y: 0, width: 200, height: 200 }}\n                                    onFocus={onFocus}\n                                    {...props}\n                                />\n                            }}\n                        </StyledList>\n                    </FocusableContainer>\n                )\n            }}\n        </AutoSizer>\n    )\n\n}","import React, { useCallback, useState } from 'react'\nimport Styled from 'styled-components'\n\nimport { Focusable, FocusableBaseTypes } from 'react-focusable'\n\ninterface MenuItemProps {\n    defaultFocus?: boolean\n    style?: React.CSSProperties\n    title: string\n}\n\nconst StyledButton = Styled.span<{ isFocused: boolean }>`\n    border: 1px solid rgba(0, 147, 255, ${props => props.isFocused ? 1 : 0.4});\n    border-radius: 10px;\n    height: auto;\n    padding: 10px 20px;\n    margin: 0px 10px;\n    font-size: 20pt;\n`\n\nexport const MenuItem = ({ defaultFocus, title, ...props }: MenuItemProps) => {\n    const [bounds, setBounds] = useState<FocusableBaseTypes.FocusableBounds | null>(null)\n\n    const onRef = useCallback((ref: HTMLDivElement) => {\n        setBounds(ref.getBoundingClientRect() || null)\n    }, [])\n\n    return (\n        <Focusable\n            defaultFocus={defaultFocus}\n            focusableBounds={bounds}\n            focusableKey={title.toLowerCase()}\n        >\n            {(focusable) => {\n                return <StyledButton\n                    {...props}\n                    isFocused={focusable.isFocused}\n                    ref={onRef}\n                >\n                    {title}\n                </StyledButton>\n            }}\n        </Focusable >\n    )\n\n}","import React, { useCallback, useState } from 'react'\nimport { FocusableContainer, FocusableBaseTypes } from 'react-focusable'\nimport Styled from 'styled-components'\n\nimport { MenuItem } from \"./MenuItem\"\n\nconst StyledContainer = Styled.div`\n    width: 100%;\n    height: 60px;\n    display: flex;\n    align-items: center;\n    box-sizing: border-box;\n`\n\nexport const Menu = () => {\n    const [bounds, setBounds] = useState<FocusableBaseTypes.FocusableBounds | null>(null)\n\n    const onRef = useCallback((ref: HTMLDivElement) => {\n        setBounds(ref.getBoundingClientRect() || null)\n    }, [])\n\n    return (\n        <FocusableContainer\n            focusableBounds={bounds}\n            focusableKey=\"menu\"\n        >\n            <StyledContainer\n                ref={onRef}\n            >\n                <MenuItem title='Home' />\n                <MenuItem title='Movies' />\n                <MenuItem title='Series' />\n            </StyledContainer>\n        </FocusableContainer>\n    )\n\n}","import React from 'react'\nimport { Focusable, FocusableContainer, FocusableDebugger } from 'react-focusable'\n\nimport { FixedList } from './components/FixedList'\nimport { Menu } from './components/Menu'\n\nconst App = () => {\n    return (\n        <>\n            <FocusableDebugger interactive={true} />\n            <Menu />\n            <FocusableContainer\n                focusableBounds={{\n                    x: 0, y: 70, width: 300, height: 100\n                }}\n                focusableKey='container'\n            >\n                <Focusable\n                    focusableBounds={{ x: 0, y: 0, width: 300, height: 50 }}\n                    focusableKey=\"button\"\n                >\n                    {(focusable) => {\n\n                        return <p style={{ color: focusable.isFocused ? 'red' : 'black' }}>ahoj</p>\n                    }}\n\n                </Focusable>\n            </FocusableContainer>\n            <FixedList focusableKey='first' />\n            {/*<FixedList focusableKey='second' />\n            <FixedList focusableKey='third' /> */}\n        </>\n    )\n}\n\nexport default App","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport { focus, focusableDebugger } from 'react-focusable'\n\nimport App from './app'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\ndocument.onkeyup = ({ key }) => {\n    switch (key) {\n        case 'ArrowDown':\n            focus.down()\n            break;\n        case 'ArrowLeft':\n            focus.left()\n            break;\n        case 'ArrowRight':\n            focus.right()\n            break;\n        case 'ArrowUp':\n            focus.up()\n            break;\n        case 'f':\n            focusableDebugger.stepForward()\n            break;\n        case 'b':\n            focusableDebugger.stepBackward()\n            break\n    }\n}"],"sourceRoot":""}